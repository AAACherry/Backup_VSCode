#include <iostream>
using namespace std;

int main()
{
    // 重载只能改变具体的规则，但是大层次上的优先级和结合性是不能改变的。比如说你去修改班级座位/班规，但是校规永远>班规
    /*假设重载过了+号和*号
    obj = obj1 + obj2 * obj3;//重载完之后还是先算乘法，然后再去算加法，然后再按照赋值运算符优先级在此处最低的情况再把值赋给obj
    相当于:obj = obj1 +( obj2 * obj3 ) ;
    */
    return 0;
}

/*
 07 - 02 规则详解
1 、并不是所有的运算符都可以重载
    可以重载的 ：
    加减乘除、 求余数的算术运算符、 6 个位运算符、 赋值运算符、 复合赋值运算符的加减等、 关系运算符 （< 、> 、≥ 、≤ 、= =、≠）、 逻辑运算符（与或非）、 自增自减、 逗号、 箭头、 new、delete（虽然是关键字，但是也可以重载）
    其中比较特殊一点的 ：
    中括号（应该叫下标运算符）、 圆括号（圆括号作为函数调用运算符的时候可以重载），
    自增自减（有前置和后置的区别，重载的时候需要注意一下，可以使用一个叫占位参数）、

    注：
    自增自减由于它本身所重载的运算符就是相同的，所以不管是前置还是后置，都是自增或者自减，它的参数、操作数什么的都一样，所以就搞一个占位参数才可以去区分一下他们。

    占位重载，比如图中：多了一个 int 占了一个位置，但是并没有什么实际意义，就告诉我们两个函数是不一样的，仅此而已，这个就叫做占位参数

    不能重载 ：
    sizeof 不能重载、
    三目运算符不能重载、
    成员运算符点、
    作用域运算符
 */

/*
2.重载不能改变运算符的优先级和结合性

    相当于国家法规 > 地方法规
    重载只能改变具体的规则，但是大层次上的优先级和结合性是不能改变的。比如说你去修改班级座位或者
    班规，但是校规永远 >班规

假设重载过了 +号和 *号
    重载完之后还是先算乘法，然后再去算加法，再按照赋值运算符优先级在此处最低的情况再把值赋给obj
 */

/*
3. 重载不会改变运算符的用法
    就是说我们原来去用这个运算符的时候，它有几个操作数，就是说它原本是单目运算符，重载完后还是单目运算符。用法除了目数以外还有一条，操作数是在左边还是右边也是不会改变的（相当于是结合性不会被改变）。

4. 运算符重载不能有默认的参数
    我们是通过函数重载的这么一种形式去实现运算符的重载，那么运算符重载肯定是会有参数的。但是不能去增加默认的参数
        举个例子：
        加法写成全局函数是需要两个参数，而且两个参数它必须要传才能够做加法，不传的话少一个都加不了。但是如果给他一个默认的参数的话，传参数没问题，少传一个好像在函数层面上也可以正常调用。但是在运算符层面，本来需要两个东西才能加起来，现在有了一种默认的参数，一个东西也能加起来了。这就相当于改变了运算符的操作数,
    也就改变了它的目数。

5. 运算符重载函数可以作为类的成员函数，可以作为全局函数
    作为类的成员函数时，是普通成员函数，有 this 指针，就是你自己，谁去调这个成员函数的时候就会去指向它，所以说只需要一个参数。（由于 this 指针占用了一个位置，所以作为成员函数去写的话，重载任何运算符都要在它原本目数的数量下减少一个参数）
        但是作为全局函数就没有 this 指针，该是多少个参数就是多少个参数。

6. 箭头运算符、下标运算符、赋值运算符、函数调用运算符只能以成员函数的形式重载
    箭头运算符->
    下标运算符[]
    赋值运算符 =
    函数调用运算符 ()
    只能以成员函数的形式重载

    也有最好用全局函数去写的运算符重载，输入输出的左移右移的那两个重载
*/

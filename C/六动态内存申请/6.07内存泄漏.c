// 内存开辟了，没有合理的释放，相当于把内存浪费了。这叫内存泄漏
// 总结：申请的内存，一定不要把首地址给丢了，在不用的时候一定要释放内存。并要防止野指针，赋值NULL
/*
内存泄露的概念：
    申请的内存，首地址丢了，找不了，再也没法使用了，也没法释放了，这块内存就被泄露了。
 */

/*
 内存泄漏案例1:指向别的空间,原先的空间找不到了
int main() 2
{
    char *p;
    p = (char *)malloc(100);
    // 接下来，可以用p指向的内存了
    p = "hello world"; // p指向别的地方了，保存字符串常量的首地址
    // 从此以后，再也找不到你申请的100个字节了。则动态申请的100个字节就被泄露了
    return 0;
} */

/*
内存泄漏案例2:开辟/使用了代码空间，但是既没有释放，也没有返回。
//也就意味着当这个函数执行完毕后根本就不知道这块堆区的空间在哪。所以泄漏了。每调用一次就泄漏一次。
void fun()//开辟空间后可能要对p做任何的操作，但是没有释放，也没有返回
{
    char *p;
    p = (char *)malloc(100);
    // 接下来，可以用p指向的内存了
    ...
}
int main()
{
    // 每调用一次fun泄露100个字节
    fun();
    fun();
    return 0;
} */

/*
解决方式1:申请/使用堆区空间完后free释放掉
void fun()
{
    char *p;
    p = (char *)malloc(100);
    // 接下来，可以用p指向的内存了
    ...
    free(p);
}
int main()
{
    fun();
    fun();
    return 0;
}
*/

/*
解决方式2:将我们申请的空间首地址返回，操作完毕之后再释放
char *fun()
{
    char *p;
    p = (char *)malloc(100);
    // 接下来，可以用p指向的内存了
    ...
    return p;
}
int main()
{
    char *q;
    q = fun();
    // 可以通过q使用 ，动态申请的100个字节的内存了
    // 记得释放
    free(q);
    // 防止野指针
    q = NULL;
    return 0;
}
*/

// 总结：申请的内存，一定不要把首地址给丢了，在不用的时候一定要释放内存。并要防止野指针，赋值NULL
/* 
1、malloc函数
    头文件：#include <stdlib.h>
    函数原型:void *malloc(unsigned int size)
    功能说明:
        再内存的动态存储区(堆区)中分配一块长度为size字节的连续区域。用来存放类型说明符指定的类型。
        函数原型返回void *指针，使用时必须做相应的强制类型转换，分配的内存空间内容不确定，一般使用memest初始化。
    返回值：
        分配空间的起始地址(分配成功)
        NULL(分配失败)
注意：
    1、在调用malloc之后，一定要判断一下，是否申请内存成功。
    2、如果多次malloc申请的内存，第1次和第2次申请的内存不一定是连续的。
    3、使用malloc开辟空间需要保存开辟好的空间的首地址，但是由于不确定空间用于干什么，所以本身返回值类型为void *，所以
    在调用函数时根据接收者的类型对其进行强制类型的转换。(也就意味着:在使用malloc函数的时候，一般情况下我们都需要进行
    强转成跟返回值类型一样的)

#include <stdlib.h>
void *malloc(unsigned int size);
功能:在堆区开辟指定的空间，并且空间是连续的
参数：
    size:要开辟的空间的大小
返回值:
    成功:开辟好的空间的首地址
    失败:NULL 

*/

#include <stdio.h>
#include <stdlib.h>
char *fun()
{
    //char ch[100] = {"hello world"};//函数结束释放空间，所以结果返回为NULL
    
    //静态全局区，只要开辟好后，除非程序结束，否则不会释放。所以如果是临时使用，不建议使用静态全局区的空间。
    //static char ch[100] = {"hello world"};//保存在静态变量全局区，这样数据就不会释放。
    // 但是有一个问题，比方说我们在主函数p=fun();中使用完后就不想用它了，我们的程序还要运行很长一段时间。那么会产生一个问题，静态全局区所对应的空间，只要开辟好后，除非程序结束，否则是不会释放的。

    //堆区开辟空间，手动申请，手动释放更加灵活。
    //使用mallo函数的时候一般都需要进行强转。
    //如果不想强转也可以，但是仅限于把其他类型转换成void *型是可以的，但是void *型转换成其他类型是不可以的。所以最好进行强转
    char *str = malloc(100 * sizeof(char));//开辟好空间后，要对空间进行操作，所以我们要接受maloc的返回值，即表示开辟空间的首地址。此处相当于用char *str来保存开辟好的空间的首地址
    //我们之前说过，malloc不知道事先要怎么去赋值和使用，所以返回值类型是void *,(是个通用指针)，所以我们在创建的时候需要对它进行强制类型转换。与前面的指针变量类型保存一致就可以了

    str[0] = 'h';//我们在堆区开辟空间就相当于开辟了一段连续的空间，所以我们在使用的时候，就类似于可以数组。所以可以这样去赋值
    //*str = 'h';  //*str也是可以的
    //*(str + 1) = 'e';
    str[1] = 'e';
    str[2] = 'l';
    str[3] = 'l';
    str[4] = 'o';
    str[5] = '\0';

    return str;
}



int main(int argc, int argv[])
{
    char *p;
    p = fun();
    printf("p=%s\n", p);
    return 0;
}
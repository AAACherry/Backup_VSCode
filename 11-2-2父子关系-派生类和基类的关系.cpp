// 11-2-2继承和派生父子关系-派生类和基类的关系
//(以单继承来简单讨论一下)

/*
子类是父类的对象，但是父类的对象不是子类的对象
派生类的对象可以当作基类对象来使用，因为派生类是继承了基类中所有的成员，也就是说基类有的派生类也有，既然如此，那么我直接用派生类不是也可以吗
（假设：父类有 50 块钱，而子类有 100 块钱，父类可以买的东西子类也可以买下。这就是用父类的地方可以用子类去用，因为子类本身就包含了父类所有的东西，并且它还新增了自己的一些东西。所以说父类拿下的东西，子类必拿下）
*/

#include <iostream>
using namespace std;

class Father
{
public:
    Father();
    ~Father();
};

class Son : public Father
{
public:
    Son();
    ~Son();
};

int main()
{
    // 子类对象也给父类对象赋值，父类对象不能给子类对象赋值
    // 父类指针可以指向子类对象，而子类指针不能指向父类对象
    // 原因都在内存图（obsidian）上面。子类比父类多一些东西，赋值的话给不满就不能给，读内存的话读不够也不行
    Father obj_fat; //定义一个父类的对象
    Son obj_son;    //定义一个子类的对象

    obj_fat = obj_son; //用子类对象给父类对象赋值，可以。父类对象可以接受子类对象给的值(父类对象可以用子类对象赋值)
    // obj_son = obj_fat;//用父类对象给子类对象赋值，不行。子类对象不能接受父类对象给的值(子类对象不能用父类对象赋值)

    Father *p_fat;    //定义一个父类的指针
    p_fat = &obj_fat; //父类类型的指针取父类对象的首地址给它,类型匹配，毫无问题
    p_fat = &obj_son; //子类对象的首地址给父类类型的指针，父类指针可以指向子类对象

    Son *p_son; //定义一个子类的指针
    // p_son = &obj_fat;//子类指针不能指向父类对象
    p_son = &obj_son; //子类类型的指针取子类对象的首地址给它,类型匹配，毫无问题

    /*
        cout << "obj_fat=" << sizeof(obj_fat) << endl;//一个字节，大小跟编译器有关
        cout << "*p_fat=" << sizeof(*p_fat) << endl;//一个字节，视频中说指针为4个字节
        cout << "obj_son=" << sizeof(obj_son) << endl;//一个字节
        cout << "*p_son=" << sizeof(*p_son) << endl;//一个字节
     */
    return 0;
}

//将构造函数和析构函数放在主函数后面
/* Father类的相关函数*/
//在父类和子类的构造中分别给数据成员一个值，用以区分子类对象访问同名数据成员时的情况
Father::Father()
{
}
Father::~Father()
{
}

/* Son类的相关函数*/
Son::Son()
{
}
Son::~Son()
{
}
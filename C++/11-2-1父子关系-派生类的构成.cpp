// 11 - 2 - 1继承与派生父子关系 - 派生类的构成

#include <iostream>
using namespace std;

class Father_1 //测试具有多个父子类有同名的数据成员的情况
{
public:
    Father_1();
    ~Father_1();

    int val; //设置一个同名的数据成员
    int a;   //其他正常使用，不受影响
};

class Father
{
public:
    Father();
    ~Father();

    int val; //设置一个同名的数据成员
    int num; //在父类当中定义一个与子类具有的同名的数据成员
    int b;   //其他正常使用，不受影响
};

class Son : public Father, public Father_1
{
public:
    Son();
    ~Son();

    int num;
    int val; //如果子类中也有同名的数据成员val
};

int main()
{
    Son obj_son; //创建一个子类的对象，如果查看内存则为：3X4=12个字节，val+父类的num+子类num。无法得知 调用的是谁的num
    obj_son.num; //子类的对象可以点到（访问到）自己的num
    obj_son.val; //也可以点到父类继承过来的val（在没有多个父类有同名数据成员时）
    //当有多个父类有同名的数据成员时，子类无法搞清是访问哪个val(两个val都不是自己的，都是从父类中继承过来的),如果自己也有val则可以访问，因为继承的两个同名的val都被屏蔽了

    cout << "obj_son.num=" << obj_son.num << endl; //输出一下子类对象.num的值,看看具有同名数据成员时访问的是谁的数据成员。得到结果：99，说明我们是通过这个子类的构造函数给的99，也就是说该num使用的是子类的数据成员，说明具有同名的数据成员时，父类的会被自动屏蔽，直接访问的是访问到子类的同名的数据成员，当然，父类的同名数据成员num还在
    //当然，父类的同名数据成员还在，那么我们怎样才能找到这个被藏起来的父类同名数据成员 num 呢？子类中共有三个成员（父类继承过来的 val 和 num，子类本身具有的num）,所以没法用 this 指针区分开来，因为这三个东西都是属于自己的了，继承过来当然就是自己的了，是他自己的当然就无法区分开来。
    // 通过父类类名 + 作用域符来访问到同名的数据成员
    cout << "obj_son.Father::num=" << obj_son.Father::num << endl; //输出结果:20，说明访问到的是父类的同名数据成员

    //多个父子类有同名的数据成员时，同样用类名+作用域符去访问到同名的数据成员
    cout << "obj_son.val=" << obj_son.val << endl;
    cout << "obj_son.Father::val=" << obj_son.Father::val << endl;
    cout << "obj_son.Father_1::val=" << obj_son.Father_1::val << endl;

    return 0;
}

//将构造函数和析构函数放在主函数后面
/* Father类的相关函数*/
//在父类和子类的构造中分别给数据成员一个值，用以区分子类对象访问同名数据成员时的情况
Father::Father()
{
    val = 10; //给同名的数据成员不同的一个值，用以区分访问的情况(多个父子类有同名数据成员时)
    num = 20; //给同名的数据成员不同的一个值，用以区分访问的情况单(对父子类有同名数据成员时)
    b = 2;    //其他不受影响
}
Father::~Father()
{
}

/* Son类的相关函数*/
Son::Son()
{
    num = 99; //给同名的数据成员不同的一个值，用以区分访问的情况单(对父子类有同名数据成员时)
    val = 88; //给同名的数据成员不同的一个值，用以区分访问的情况单(对父子类有同名数据成员时)
}

Son::~Son()
{
}

//将Faher_1的构造和析构写在Son的构造和析构的后面，来测试如果有多个父子类的具有同名数据成员
Father_1::Father_1()
{
    val = 100; //给同名的数据成员不同的一个值，用以区分访问的情况(多个父子类有同名数据成员时)
    a = 1;     //其他不受影响
}
Father_1::~Father_1()
{
}